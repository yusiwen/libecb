=head1 LIBECB

You suck, we don't(tm)

=head2 ABOUT THE HEADER

- how to include it
- it includes inttypes.h
- no .a
- whats a bool

=head2 GCC ATTRIBUTES

blabla where to put, what others

=over 4

=item ecb_attribute ((attrs...))

A simple wrapper that expands to C<__attribute__((attrs))> on GCC, and
to nothing on other compilers, so the effect is that only GCC sees these.

=item ecb_unused

Marks a function or a variable as "unused", which simply suppresses a
warning by GCC when it detects it as unused. This is useful when you e.g.
declare a variable but do not always use it:

   {
     int var ecb_unused;

     #ifdef SOMECONDITION
        var = ...;
        return var;
     #else
        return 0;
     #endif
   }

=item ecb_noinline

Prevent a function from being inlined - it might be optimsied away, but
not inlined into other functions. This is useful if you know your function
is rarely called and large enough for inlining not to be helpful.

=item ecb_noreturn

=item ecb_const

=item ecb_pure

=item ecb_hot

=item ecb_cold

=item ecb_artificial

=back

=head2 OPTIMISATION HINTS

=over 4

=item bool ecb_is_constant(expr)

Returns true iff the expression can be deduced to be a compile-time
constant, and false otherwise.

For example, when you have a C<rndm16> function that returns a 16 bit
random number, and you have a function that maps this to a range from
0..n-1, then you could use this inline function in a header file:

  ecb_inline uint32_t
  rndm (uint32_t n)
  {
    return n * (uint32_t)rndm16 ()) >> 16;
  }

However, for powers of two, you could use a normal mask, but that is only
worth it if, at compile time, you can detect this case. This is the case
when the passed number is a constant and also a power of two (C<n & (n -
1) == 0>):

  ecb_inline uint32_t
  rndm (uint32_t n)
  {
    return is_constant (n) && !(n & (n - 1))
      ? rndm16 () & (num - 1)
      : (uint32_t)rndm16 ()) >> 16;
  }

=item bool ecb_expect(expr,value)

=item bool ecb_unlikely(bool)

=item bool ecb_likely(bool)

=item bool ecb_assume(cond)

=item bool ecb_unreachable()

=item bool ecb_prefetch(addr,rw,locality)

=back

=head2 BIT FIDDLING / BITSTUFFS

=over 4

=item bool ecb_big_endian ()

=item bool ecb_little_endian ()

=item int ecb_ctz32 (uint32_t x)

=item int ecb_popcount32 (uint32_t x)

=item uint32_t ecb_bswap32 (uint32_t x)

=item uint32_t ecb_bswap16 (uint32_t x)

=item uint32_t ecb_rotr32 (uint32_t x, unsigned int count)

=item uint32_t ecb_rotl32 (uint32_t x, unsigned int count)

=back

=head2 ARITHMETIC

=over 4

=item x = ecb_mod (m, n) [MACRO]

=back

=head2 UTILITY

=over 4

=item ecb_array_length (name) [MACRO]

=back


